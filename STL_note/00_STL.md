* 👋 Hi, I’m liubo
* 👀 I’m interested in harmony
* 🌱 I’m currently learning harmony
* 💞️ I’m looking to collaborate on ...
* 📫 How to reach me ...



# STL









## 概述

长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”的方法，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。



复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦的来源。



为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹性、交互操作性(相互合作性,interoperability),诞生了STL。



STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。



STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)。

容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。



STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以上。










## STL六大组件简介

STL提供了六大组件，彼此之间可以组合套用，这六大组件分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。

容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据，从实现角度来看，STL容器是一种class template。

算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.

迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator* , operator-> , operator++,operator–等指针相关操作予以重载的class template. 所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。

仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template

适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。

空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.

STL六大组件的交互关系，容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。








## STL的优点很明显了

STL 是 C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。
STL 的一个重要特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”,以使算法可以和容器交互运作
程序员可以不用思考 STL 具体的实现过程，只要能够熟练使用 STL 就 OK 了。这样他们就可以把精力放在程序开发的别的方面。
STL 具有高可重用性，高性能，高移植性，跨平台的优点。
    高可重用性：STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。
    高性能：如 map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体实现的。
    高移植性：如在项目 A 上用 STL 编写的模块，可以直接移植到项目 B 上。











## 容器



### 容器的概念

C++中容器的定义如下：

容器是一种存储数据的对象类型，它持有其他对象或指向其他对象的指针。



容器类是一种对特定代码重用问题的良好的解决方案。容器另一个好处就是可以自行扩展，解决问题时通常不知道需要存储多少个对象，数组在这方面也是力不从心。容器可以申请内存、释放内存，并且使用最优的算法来执行命令。



几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。STL容器实现了运用最广泛的一些数据结构，包括：数组(array) , 链表(list), tree(树)，栈(stack), 队列(queue), 集合(set),映射表(map)。根据数据在容器中的排列特性，这些容器可分为序列式容器和关联式容器。



- 序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。
- 关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set/multiset容器 Map/multimap容器





2. 算法

算法，问题的解法，以有限的步骤，解决逻辑或数学上的问题。

我们所编写的每个程序都是一个算法，其中的每个函数也都是一个算法，毕竟它们都是用来解决或大或小的逻辑问题或数学问题。STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。

算法分为:质变算法和非质变算法。





质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等
非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等









3. ## 迭代器

迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。 在<<Design Patterns>>一书中提供了23种设计模式的完整描述， 其中iterator模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。

迭代器的设计思维-STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。

从技术角度来看，容器和算法的泛型化并不困难，c++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。

迭代器的种类:










| 迭代器         | 功能                                                         | 描述                                   |
| -------------- | ------------------------------------------------------------ | -------------------------------------- |
| 输入迭代器     | 提供对数据的只读访问                                         | 只读，支持++、==、！=                  |
| 输出迭代器     | 提供对数据的只写访问                                         | 只写，支持++                           |
| 前向迭代器     | 提供读写操作，并能向前推进迭代器                             | 读写，支持++、==、！=                  |
| 双向迭代器     | 提供读写操作，并能向前和向后操作                             | 读写，支持++、–，                      |
| 随机访问迭代器 | 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器 | 读写，支持++、–、[n]、-n、<、<=、>、>= |
|                |                                                              |                                        |
|                |                                                              |                                        |



















































版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/qq_42322103/article/details/99685797

























# 3. STL

STL知识点总结：[快速跳转](https://blog.csdn.net/weixin_44515978/article/details/117562374)





## **26.** ***\*3.8 什么情况下用vector，什么情况下用list，什么情况下用deque\****

· vector可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。

· list不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。

· 需要从首尾两端进行插入或删除操作的时候需要选择deque。

## **27.** ***\*3.9 priority_queue的底层原理\****

priority_queue：优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。

## **28.** ***\*3.10 map 、set、multiset、multimap的底层原理\****

· map 、set 、multiset 、multimap的底层实现都是红黑树 ，epoll模型的底层数据结构也是红黑树 ，linux 系统中CFS 进程调度算法，也用到红黑树 。

· 红黑树的特性：

o 每个结点或是红色或是黑色；

o 根结点是黑色；

o 每个叶结点是黑的；

o 如果一个结点是红的，则它的两个儿子均是黑色；

o 每个结点到其子孙结点的所有路径上包含相同数目的黑色结点。

## **29.** ***\*3.11 为何map和set的插入删除效率比其他序列容器高\****

因为不需要内存拷贝和内存移动

## **30.** ***\*3.12 为何map和set每次Insert之后，以前保存的iterator不会失效？\****

因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。

## **31.** ***\*3.13 当数据元素增多时（从10000到20000），map的set的查找速度会怎样变化？\****

RB-TREE用二分查找法，时间复杂度为logn，所以从10000增到20000时，查找次数从log10000=14次到log20000=15次，多了1次而已。

## **32.** ***\*3.14 map 、set、multiset、multimap的特点\****

· set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。

· map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以map默认是按key排序的），map中元素的key不允许重复，multimap可以重复。

· map和set的增删改查速度为都是logn，是比较高效的。

## **33.** ***\*3.15 为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？\****

· 存储的是结点，不需要内存拷贝和内存移动。

· 插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。

## **34.** ***\*3.16 为何map和set不能像vector一样有个reserve函数来预分配数据?\****

· 在map和set内部存储的已经不是元素本身了，而是包含元素的结点。也就是说map内部使用的Alloc并不是map<Key, Data, Compare, Alloc>声明的时候从参数中传入的Alloc。

## **35.** ***\*3.17 set的底层实现实现为什么不用哈希表而使用红黑树？\****

· set中元素是经过排序的，红黑树也是有序的，哈希是无序的

· 如果只是单纯的查找元素的话，那么肯定要选哈希表了，因为哈希表在的最好查找时间复杂度为O(1)，并且如果用到set中那么查找时间复杂度的一直是O（1），因为set中是不允许有元素重复的。而红黑树的查找时间复杂度为O(lgn)

## **36.** ***\*3.18 hash_map与map的区别？什么时候用hash_map，什么时候用map？\****

· 构造函数：hash_map需要hash function和等于函数，而map需要比较函数（大于或小于）。

· 存储结构：hash_map以hashtable为底层，而map以RB-TREE为底层。

· 总的说来，hash_map查找速度比map快，而且查找速度基本和数据量大小无关，属于常数级别。而map的查找速度是logn级别。但不一定常数就比log小，而且hash_map还有hash function耗时。

· 如果考虑效率，特别当元素达到一定数量级时，用hash_map。

· 考虑内存，或者元素数量较少时，用map。

## **37.** ***\*3.19 迭代器失效的问题\****

插入操作：

· 对于vector和string，如果容器内存被重新分配，iterators,pointers,references失效；如果没有重新分配，那么插入点之前的iterator有效，插入点之后的iterator失效；

· 对于deque，如果插入点位于除front和back的其它位置iterators,pointers,references失效；当我们插入元素到front和back时，deque的迭代器失效，但reference和pointers有效；

· 对于list和forward_list，所有的iterator,pointer和refercnce有效。 删除操作：

· 对于vector和string，删除点之前的iterators,pointers,references有效；off-the-end迭代器总是失效的；

· 对于deque，如果删除点位于除front和back的其它位置，iterators,pointers,references失效；当我们插入元素到front和back时，off-the-end失效，其他的iterators,pointers,references有效；

· 对于list和forward_list，所有的iterator,pointer和refercnce有效。

· 对于关联容器map来说，如果某一个元素已经被删除，那么其对应的迭代器就失效了，不应该再被使用，否则会导致程序无定义的行为。

## **38.** ***\*3.20 STL线程不安全的情况\****

· 在对同一个容器进行多线程的读写、写操作时；

· 在每次调用容器的成员函数期间都要锁定该容器；

· 在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器；

· 在每个在容器上调用的算法执行期间锁定该容器。
















---

---

---

---

---

---

---

---

---

---

---

---

---

---

---

---

---

---

---

---













  
